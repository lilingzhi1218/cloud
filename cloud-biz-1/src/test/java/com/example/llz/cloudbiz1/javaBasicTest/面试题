1.String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.
  所以尽量不要对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.
2.StringBuffer是对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer(线程安全).
3.StringBuffer和StringBuilder的实现原理一样,其父类都是AbstractStringBuilder.StringBuffer是线程安全的,
  StringBuilder是JDK 1.5新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.
4.如何将byte转为String
  可以使用String接收 byte[] 参数的构造器来进行转换,注意要使用的正确的编码,否则会使用平台默认编码.这个编码可能跟原来的编码相同.也可能不同.
5.可以将int强转为byte类型么?会产生什么问题?
  可以做强制转换,但是Java中int是32位的而byte是8 位的.如果强制转化int类型的高24位将会被丢弃,byte 类型的范围是从-128到128.
6.a=a+b与a+=b有什么区别吗?
  +=操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：
  byte a = 127;
  byte b = 127;
  b = a + b; // 报编译错误:cannot convert from int to byte
  b += a; 
  以下代码是否有错？
  short s1= 1;
  s1 = s1 + 1;
  有错误.short类型在进行运算时会自动提升为int类型,也就是说s1+1的运算结果是int类型,而s1是short类型,此时编译器会报错.
  以下代码是否有错？
  short s1= 1;
  s1 += 1;
  +=操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错
7.了解泛型么?简述泛型的上界和下界?
  有时候希望传入的类型有一个指定的范围，从而可以进行一些特定的操作,这时候就需要通配符了?在Java中常见的通配符主要有以下几种:
  <?>: 无限制通配符
  <? extends E>: extends 关键字声明了类型的上界,表示参数化的类型可能是所指定的类型,或者是此类型的子类
  <? super E>: super关键字声明了类型的下界,表示参数化的类型可能是指定的类型,或者是此类型的父类
  它们的目的都是为了使方法接口更为灵活,可以接受更为广泛的类型.
  
  < ? extends E>: 用于灵活读取，使得方法可以读取 E 或 E 的任意子类型的容器对象。
  < ? super E>: 用于灵活写入或比较,使得对象可以写入父类型的容器,使得父类型的比较方法可以应用于子类对象。
  用简单的一句话来概括就是为了获得最大限度的灵活性,要在表示生产者或者消费者的输入参数上使用通配符,
  使用的规则就是:生产者有上限(读操作使用extends),消费者有下限(写操作使用super)
8.垃圾回收
  简单的解释一下垃圾回收?
  JVM中垃圾回收机制最基本的做法是分代回收.内存中的区域被划分成不同的世代,对象根据其存活的时间被保存在对应世代的区域中.
  一般的实现是划分成3个世代:年轻,年老和永久代.所有新生成的对象优先放在年轻代的(大对象可能被直接分配在老年代,作为一种分配担保机制),
  年轻代按照统计规律被分为三个区:一个Eden区，两个 Survivor区.在年轻代中经历了N次垃圾回收后仍然存活的对象,就会被放到年老代中.
  因此可以认为年老代中存放的都是一些生命周期较长的对象.
  
  方法区也被称为永久代,用于存储每一个java类的结构信息:比如运行时常量池,字段和方法数据,构造函数和普通方法的字节码内容以及类,实例,
  接口初始化时需要使用到的特殊方法等数据,根据虚拟机实现不同,GC可以选择对方法区进行回收也可以不回收.
  对于不同的世代可以使用不同的垃圾回收算法。比如对由于年轻代存放的对象多是朝生夕死,因此可以采用标记-复制,而对于老年代则可以采用标记-整理/清除.

9.Minor GC
  发生在新生代的GC为Minor GC.在Minor GC时会将新生代中还存活着的对象复制进一个Survivor中,然后对Eden和另一个Survivor进行清理.所以,平常可用的新生代大小为Eden的大小+一个Survivor的大小.
  
10.Major GC
  在老年代中的GC则为Major GC.
  
11.Full GC
  通常是和Major GC等价的,针对整个新生代,老年代,元空间metaspace(java8以上版本取代perm gen)的全局范围的GC.
  
  关于GC的类型,其实依赖于不同的垃圾回收器.可以具体查看相关垃圾回收器的实现.

12.新生代进入老年代
   分配担保机制:当Minor GC时,新生代存活的对象大于Survivor的大小时,这时一个Survivor装不下它们,那么它们就会进入老年代.
   如果设置了-XX：PretenureSizeThreshold5M 那么大于5M的对象就会直接就进入老年代.
   在新生代的每一次Minor GC 都会给在新生代中的对象+1岁,默认到15岁时就会从新生代进入老年代,可以通过-XX：MaxTenuringThreshold来设置这个临界点
   常见的垃圾回收算法有哪些?简述其原理.
   垃圾回收从理论上非常容易理解,具体的方法有以下几种:
   标记-清除
   标记-复制
   标记-整理
   分代回收
13.如何判断一个对象是否应该被回收?
   这就是所谓的对象存活性判断,常用的方法有两种:
   （1）引用计数法
   （2）对象可达性分析
   由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.
14.哪些对象可以做GC Root?
   JVM的标记算法我们可以了解为一个可达性算法，所以所有的可达性算法都会有起点，那么这个起点就是GC Root。
   主要由以下四种:
   JVM方法栈中引用的对象
   本地方法栈中引用的对象
   方法区常量引用的对象
   方法区类属性引用的对象
15.调用System.gc()会发生什么?
   通知GC开始工作,但是GC真正开始的时间不确定.
16.了解java当中的四种引用类型?他们之间的区别是什么?
   在java中主要有以下四种引用类型:强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:
   （1）强引用:如果一个对象具有强引用,它就不会被垃圾回收器回收.即使当前内存空间不足,JVM也不会回收它.而是抛出 OutOfMemoryError 错误.
       使程序异常终止.如果想中断强引用和某个对象之间的关联.可以显式地将引用赋值为null,这样一来的话.JVM在合适的时间就会回收该对象.
   （2）软引用:在使用软引用时,如果内存的空间足够,软引用就能继续被使用而不会被垃圾回收器回收.只有在内存不足时,软引用才会被垃圾回收器回收.
   （3）弱引用:具有弱引用的对象拥有的生命周期更短暂.因为当 JVM 进行垃圾回收,一旦发现弱引用对象,无论当前内存空间是否充足,都会将弱引用回收.
       不过由于垃圾回收器是一个优先级较低的线程,所以并不一定能迅速发现弱引用对象.
   （4）虚引用:如果一个对象仅持有虚引用,那么它相当于没有引用,在任何时候都可能被垃圾回收器回收.
   
17.spring的bean作用域都有哪些？默认是哪个？
   作用域	字符	        描述
   单例	    singleton	整个应用中只创建一个实例
   原型	    prototype	每次注入时都新建一个实例
   会话	    session	    为每个会话创建一个实例
   请求	    request	    为每个请求创建一个实例
   默认的是：单例 singleton
18.创建单例的方式是否线程安全
   （1）懒汉式（不安全写法）
   public class Singleton{ 
       private Singleton(){}
       private static Singleton singleton = null；  //不建立对象
       public static Singleton getInstance(){
                if(singleton == null) {        //先判断是否为空
                    singleton = new Singleton ();  //懒汉式做法 
                }
                return singleton;
        }
   }
   （2）饿汉式
      public class Singleton{ 
          public Singleton(){}
          private static Singleton singleton = new Singleton()；  //建立对象
          public static Singleton getInstance(){
            return singleton;//直接返回单例对象 
          }
      }
    这两种创建方式中，懒汉式在多线程环境下就是线程不安全的，假设有线程1和线程2两个线程，线程1在判断if(singleton == null)的时候，突然失去cpu的执行权，
    而线程2获得了cpu的执行权，执行了getInstance()方法，创建了个对象，但是这个事情线程1并不知道，线程1重新获得cpu的执行权时，判断f(singleton == null)结果是null，
    所以又去创建了对象，那么这样就会出现破坏单例的情况，有多余的对象，所以线程是不安全的，解决方案之一就是加锁，代码如下
   （3）懒汉式（安全写法）
    public class Singleton{ 
        private Singleton(){}
        private static Singleton singleton = null；  //不建立对象
        public static synchronized Singleton getInstance(){
                 if(singleton == null) {        //先判断是否为空
                     singleton = new Singleton ();  //懒汉式做法 
                 }
                 return singleton;
         }
    }
    这种写法虽然保证了线程安全，但是后续线程每次在获取对象的时候不会进入if中，也就不会有线程安全问题，可这时候还是每次都进入同步块，影响性能，这是首应该采用双重监测机制
    （3）懒汉式（优化安全写法）
    public class Singleton{ 
            private Singleton(){}
            private static Singleton singleton = null；  //不建立对象
            public static Singleton getInstance(){
                 if(singleton == null) {        //先判断是否为空
                     synchronized(Singleton.class){ //为空才进入同步代码块
                        if(singleton == null){  //双重监测机制
                            singleton = new Singleton ();  //懒汉式做法
                        }
                     }
                 }
                 return singleton;
             }
    还有一种可能就是虚拟机在创建一个对象的时候有三个步骤：（1）为对象分配内存空间（2）初始化对象（3）将变量指向刚刚分配的内存地址，但是这个执行顺序不是一成不变的，
    若p1线程刚执行完（1）（3）步，线程p2就来判断singleton是否为null，结果为否，然后取到一个未初始化的对象。这时候有线程安全问题就来了。
    用volatile来保证指令重排的问题，即把singleton这个变量声明为volatile。
    （4）懒汉式（优化安全并避免指令重排的写法）
    public class Singleton{ 
        private Singleton(){}
        private static volatile Singleton singleton = null；  //不建立对象
        public static synchronized Singleton getInstance(){
             if(singleton == null) {        //先判断是否为空
                 singleton = new Singleton ();  //懒汉式做法 
             }
             return singleton;
         }
    }
    
    
19.spring创建单例的方式？
   Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 ConcurrentHashMap 对象。
    public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
        // 通过 Map 实现单例注册表
        private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);
        public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
            Assert.notNull(beanName, "'beanName' must not be null");
            synchronized (this.singletonObjects) {
                // 检查缓存中是否存在实例  
                Object singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    // ...忽略代码
                    try {
                        singletonObject = singletonFactory.getObject();
                    }
                    catch (BeanCreationException ex) {
                        // ...忽略代码
                    }
                    finally {
                        // ...忽略代码
                    }
                    // 如果实例对象在不存在，我们注册到单例注册表中。
                    addSingleton(beanName, singletonObject);
                }
                return (singletonObject != NULL_OBJECT ? singletonObject : null);
            }
        }
        protected void addSingleton(String beanName, Object singletonObject) {
            synchronized (this.singletonObjects) {
                this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
    
            }
        }
    }
*20.怎么判断使用已经创建好的单例对象是否线程安全？
   （1）看这个单例里有没有全局变量（全局变量就是成员变量，成员变量又分实例变量和静态变量）
   （2）如果有全局变量，看它是不是只可以读取而不能写入（有没有发布set方法）  
   如果满足上面两个条件，那么这个单例就是不安全的。 
21.spring的单例模式与线程安全
   
   （1）spring框架里的bean获取实例的时候都是默认单例模式，所以在多线程开发里就有可能会出现线程不安全的问题。当多个用户同时请求一个服务器时，
     容器（tomcat）会给每一个请求分配一个线程，这时多个线程会并发执行该请求所对应的业务逻辑（controller里的方法），此时就要注意啦，
     如果controller（是单例对象）里有全局变量并且又是可以修改的，那么就需要考虑线程安全的问题。解决方案有很多，
     比如设置@scope("prototype")为多例模式，为每个线程创建一个controller，还可以使用ThreadLocal。
   
   （2）其实spring的源码里比如RequestContextHolder、TransactionSynchronizationManager、LoxaleContextHolder等这些对象创建方式也是单例，
     底层就是用ThreadLocal处理的。ThreadLocal基本实现思路是：它会为每个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突，
     因为每个线程都拥有自己的变量副本，从而也就没必要对该变量进行同步啦。
22.spring单例模式和多例模式的用途
    之所以用单例，是因为没必要每个请求都新建一个对象，这样子既浪费CPU又浪费内存；
    之所以用多例，是为了防止并发问题；即一个请求改变了对象的状态，此时对象又处理另一个请求，而之前请求对对象状态的改变导致了对象对另一个请求做了错误的处理；
    
    可以全部用单例，也可以全部用非单例；
    单例：节约对象创建的时间和垃圾回收时间，但是可能面临并发的危险；
    所以大部分情况都是使用单例，只要注意在使用单例的时候可能造成的并发就可以了；
    对象属性最好是不能更改的，或者控制其更改；
    从性能上考虑的话，使用单例的配置很不错，毕竟spring默认就是使用单例，
    当然你如果已经出现了并发的问题了，就需要使用prototype了，然后再考虑怎么解决单例产生的问题；

23.自动配置
   SpringBoot的核心就是自动配置，自动配置又是基于条件判断来配置Bean。
24.SpringBoot运行原理
   (1.三个重要的注解
    我们可以发现，在使用main()启动SpringBoot的时候，只有一个注解@SpringBootApplication
    我们可以点击进去@SpringBootApplication注解中看看，可以发现有三个注解是比较重要的：
    @SpringBootConfiguration：我们点进去以后可以发现底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置(使用Configuration配置类等同于XML文件)。
    @EnableAutoConfiguration：开启自动配置功能(后文详解)
    @ComponentScan：这个注解，学过Spring的同学应该对它不会陌生，就是扫描注解，默认是扫描当前类下的package。将@Controller/@Service/@Component/@Repository等注解加载到IOC容器中。    
   (2.重点EnableAutoConfiguration
    我们知道SpringBoot可以帮我们减少很多的配置，也肯定听过“约定大于配置”这么一句话，那SpringBoot是怎么做的呢？其实靠的就是@EnableAutoConfiguration注解。
    简单来说，这个注解可以帮助我们自动载入应用程序所需要的所有默认配置。
    我们点进去看一下，发现有两个比较重要的注解：
    @AutoConfigurationPackage：自动配置包
    @Import：给IOC容器导入组件
        (2.1.AutoConfigurationPackage
             @AutoConfigurationPackage自动配置包，我们也看看@AutoConfigurationPackage里边有什么
                 @Target(ElementType.TYPE)
                 @Retention(RetentionPolicy.RUNTIME)
                 @Documented
                 @Inherited
                 @Import(AutoConfigurationPackages.Registrar.class)
                 public @interface AutoConfigurationPackage {
                 
                 }
             我们可以发现，依靠的还是@Import注解，再点进去查看，我们发现重要的就是以下的代码：
                 @Override
                 public void registerBeanDefinitions(AnnotationMetadata metadata,
                         BeanDefinitionRegistry registry) {
                     register(registry, new PackageImport(metadata).getPackageName());
                 }
             在默认的情况下就是将：主配置类(@SpringBootApplication)的所在包及其子包里边的组件扫描到Spring容器中。
             看完这句话，会不会觉得，这不就是ComponentScan的功能吗？这俩不就重复了吗？
             比如说，你用了Spring Data JPA，可能会在实体类上写@Entity注解。这个@Entity注解由@AutoConfigurationPackage扫描并加载，
             而我们平时开发用的@Controller/@Service/@Component/@Repository这些注解是由ComponentScan来扫描并加载的。
    (3总结
    @SpringBootApplication等同于下面三个注解：
    
    @SpringBootConfiguration
    @EnableAutoConfiguration
    @ComponentScan
    其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，
    然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！
    
    spring 的优点？
    1.降低了组件之间的耦合性 ，实现了软件各层之间的解耦 
    2.可以使用容易提供的众多服务，如事务管理，消息服务等 
    3.容器提供单例模式支持 
    4.容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 
    5.容器提供了众多的辅助类，能加快应用的开发 
    6.spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts等 
    7.spring属于低侵入式设计，代码的污染极低 
    8.独立于各种应用服务器 
    9.spring的DI机制降低了业务对象替换的复杂性 
    10.Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部 
    
    什么是DI机制？ 
    依赖注入（Dependecy Injection）和控制反转（Inversion of Control）是同一个概念，具体的讲：当某个角色需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。
    但在spring中创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者 因此也称为依赖注入。 
    spring以动态灵活的方式来管理对象 ， 注入的两种方式，设置注入和构造注入。 
    设置注入的优点：直观，自然 
    构造注入的优点：可以在构造器中决定依赖关系的顺序。
    
    什么是AOP？ 
    面向切面编程（AOP）完善spring的依赖注入（DI），面向切面编程在spring中主要表现为两个方面 
    1.面向切面编程提供声明式事务管理 
    2.spring支持用户自定义的切面 
    
    面向切面编程（aop）是对面向对象编程（oop）的补充， 
    面向对象编程将程序分解成各个层次的对象，面向切面编程将程序运行过程分解成各个切面。 
    AOP从程序运行角度考虑程序的结构，提取业务处理过程的切面，oop是静态的抽象，aop是动态的抽象， 
    是对应用执行过程中的步骤进行抽象，，从而获得步骤之间的逻辑划分。 
    
    aop框架具有的两个特征： 
    1.各个步骤之间的良好隔离性 
    2.源代码无关性 
     
    Spring的事务管理机制实现的原理，就是通过这样一个动态代理对所有需要事务管理的Bean进行加载，并根据配置在invoke方法中对当前调用的 方法名进行判定，
    并在method.invoke方法前后为其加上合适的事务管理代码，这样就实现了Spring式的事务管理。Spring中的AOP实 现更为复杂和灵活，不过基本原理是一致的。

AOP全局异常处理
  
自定义注解
java1.8新特性
jvm 类加载、优化
jpa
线程
redis
数据库优化
sql分页
事务
cookie和session（cookie如果被浏览器禁用了，可以加在url）

